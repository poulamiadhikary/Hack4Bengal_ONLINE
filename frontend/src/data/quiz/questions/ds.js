export const easyLevel = [
    {
        question: "Which data structure uses LIFO (Last In, First Out) order?",
        option1: "Queue",
        option2: "Stack",
        option3: "Linked List",
        option4: "Tree",
        ans: "Stack"
    },
    {
        question: "Which data structure follows FIFO (First In, First Out) order?",
        option1: "Queue",
        option2: "Stack",
        option3: "Graph",
        option4: "Tree",
        ans: "Queue"
    },
    {
        question: "Which data structure is used to implement recursion?",
        option1: "Queue",
        option2: "Stack",
        option3: "Array",
        option4: "Linked List",
        ans: "Stack"
    },
    {
        question: "Which data structure is best for searching?",
        option1: "Array",
        option2: "Linked List",
        option3: "Hash Table",
        option4: "Stack",
        ans: "Hash Table"
    },
    {
        question: "What is the worst-case time complexity of linear search?",
        option1: "O(1)",
        option2: "O(n)",
        option3: "O(log n)",
        option4: "O(n^2)",
        ans: "O(n)"
    },
    {
        question: "What is the worst-case time complexity of binary search?",
        option1: "O(n)",
        option2: "O(n^2)",
        option3: "O(log n)",
        option4: "O(1)",
        ans: "O(log n)"
    },
    {
        question: "Which data structure is used for implementing BFS (Breadth-First Search)?",
        option1: "Stack",
        option2: "Queue",
        option3: "Heap",
        option4: "Graph",
        ans: "Queue"
    },
    {
        question: "Which data structure is used for implementing DFS (Depth-First Search)?",
        option1: "Queue",
        option2: "Stack",
        option3: "Tree",
        option4: "Array",
        ans: "Stack"
    },
    {
        question: "Which of the following is a non-linear data structure?",
        option1: "Array",
        option2: "Stack",
        option3: "Queue",
        option4: "Tree",
        ans: "Tree"
    },
    {
        question: "Which data structure is most suitable for implementing undo operations?",
        option1: "Queue",
        option2: "Stack",
        option3: "Heap",
        option4: "Graph",
        ans: "Stack"
    },
    {
        question: "Which of the following is a self-balancing binary search tree?",
        option1: "Binary Tree",
        option2: "AVL Tree",
        option3: "Heap",
        option4: "Graph",
        ans: "AVL Tree"
    },
    {
        question: "Which of the following sorting algorithms has the best average case time complexity?",
        option1: "Bubble Sort",
        option2: "Selection Sort",
        option3: "Merge Sort",
        option4: "Insertion Sort",
        ans: "Merge Sort"
    },
    {
        question: "Which data structure is used to implement a priority queue?",
        option1: "Stack",
        option2: "Queue",
        option3: "Heap",
        option4: "Array",
        ans: "Heap"
    },
    {
        question: "Which data structure is best for fast lookups?",
        option1: "Stack",
        option2: "Hash Table",
        option3: "Queue",
        option4: "Linked List",
        ans: "Hash Table"
    },
    {
        question: "Which of the following has a dynamic size?",
        option1: "Array",
        option2: "Linked List",
        option3: "Stack (fixed size)",
        option4: "Queue (fixed size)",
        ans: "Linked List"
    },
    {
        question: "What is the space complexity of an array of size n?",
        option1: "O(1)",
        option2: "O(n)",
        option3: "O(log n)",
        option4: "O(n^2)",
        ans: "O(n)"
    },
    {
        question: "What is the best-case time complexity of QuickSort?",
        option1: "O(n^2)",
        option2: "O(n log n)",
        option3: "O(n)",
        option4: "O(log n)",
        ans: "O(n log n)"
    },
    {
        question: "Which of the following is NOT an application of stacks?",
        option1: "Expression Evaluation",
        option2: "Function Calls",
        option3: "Graph Traversal",
        option4: "Job Scheduling",
        ans: "Job Scheduling"
    },
    {
        question: "Which sorting algorithm is the fastest for nearly sorted data?",
        option1: "QuickSort",
        option2: "Merge Sort",
        option3: "Insertion Sort",
        option4: "Selection Sort",
        ans: "Insertion Sort"
    },
    {
        question: "Which of the following operations has the worst time complexity for a linked list?",
        option1: "Insertion at the beginning",
        option2: "Insertion at the end",
        option3: "Searching for an element",
        option4: "Deleting the first element",
        ans: "Searching for an element"
    },
    {
        question: "Which of the following data structures supports O(1) average time complexity for insertion, deletion, and search?",
        option1: "Array",
        option2: "Stack",
        option3: "Hash Table",
        option4: "Queue",
        ans: "Hash Table"
    },
    {
        question: "Which data structure is best for implementing a LRU (Least Recently Used) cache?",
        option1: "Array",
        option2: "Stack",
        option3: "Linked List + Hash Map",
        option4: "Heap",
        ans: "Linked List + Hash Map"
    },
    {
        question: "Which data structure is used in the implementation of graph algorithms like Dijkstra’s?",
        option1: "Queue",
        option2: "Stack",
        option3: "Heap",
        option4: "Linked List",
        ans: "Heap"
    },
    {
        question: "Which of the following is the most suitable data structure for storing hierarchical data?",
        option1: "Array",
        option2: "Stack",
        option3: "Queue",
        option4: "Tree",
        ans: "Tree"
    },
    {
        question: "Which sorting algorithm has an average-case complexity of O(n log n) and works well for large datasets?",
        option1: "Selection Sort",
        option2: "Bubble Sort",
        option3: "Merge Sort",
        option4: "Insertion Sort",
        ans: "Merge Sort"
    },
    {
        question: "Which of the following sorting algorithms is NOT a comparison-based algorithm?",
        option1: "QuickSort",
        option2: "Merge Sort",
        option3: "Counting Sort",
        option4: "Bubble Sort",
        ans: "Counting Sort"
    },
    {
        question: "Which of the following algorithms is used to detect cycles in a graph?",
        option1: "Kruskal's Algorithm",
        option2: "Bellman-Ford Algorithm",
        option3: "Floyd-Warshall Algorithm",
        option4: "DFS Cycle Detection",
        ans: "DFS Cycle Detection"
    },
    {
        question: "Which operation in a stack results in removing the top element?",
        option1: "Push",
        option2: "Pop",
        option3: "Peek",
        option4: "Insert",
        ans: "Pop"
    },
    {
        question: "Which operation in a queue results in inserting an element at the rear?",
        option1: "Push",
        option2: "Enqueue",
        option3: "Dequeue",
        option4: "Insert",
        ans: "Enqueue"
    }
];

export const mediumLevel = [
    {
        question: "Which of the following data structures can be used to implement a queue efficiently?",
        option1: "Array",
        option2: "Stack",
        option3: "Linked List",
        option4: "Heap",
        ans: "Linked List"
    },
    {
        question: "Which traversal method is used in a binary search tree to retrieve elements in sorted order?",
        option1: "Preorder",
        option2: "Inorder",
        option3: "Postorder",
        option4: "Level Order",
        ans: "Inorder"
    },
    {
        question: "What is the time complexity of inserting an element into a binary search tree (BST) in the worst case?",
        option1: "O(1)",
        option2: "O(log n)",
        option3: "O(n)",
        option4: "O(n log n)",
        ans: "O(n)"
    },
    {
        question: "Which of the following data structures supports efficient range queries?",
        option1: "Hash Table",
        option2: "Segment Tree",
        option3: "Queue",
        option4: "Stack",
        ans: "Segment Tree"
    },
    {
        question: "Which sorting algorithm is used in Timsort?",
        option1: "Bubble Sort",
        option2: "Insertion Sort",
        option3: "Merge Sort & Insertion Sort",
        option4: "Selection Sort",
        ans: "Merge Sort & Insertion Sort"
    },
    {
        question: "Which of the following is NOT a self-balancing binary search tree?",
        option1: "AVL Tree",
        option2: "Red-Black Tree",
        option3: "B-Tree",
        option4: "Heap",
        ans: "Heap"
    },
    {
        question: "Which algorithm is used to find the shortest path in an unweighted graph?",
        option1: "Dijkstra’s Algorithm",
        option2: "Floyd-Warshall Algorithm",
        option3: "Breadth-First Search (BFS)",
        option4: "Bellman-Ford Algorithm",
        ans: "Breadth-First Search (BFS)"
    },
    {
        question: "In a min heap, which condition must always be satisfied?",
        option1: "Parent node must be greater than child nodes",
        option2: "Parent node must be smaller than child nodes",
        option3: "Heap must be a complete binary tree",
        option4: "Both B and C",
        ans: "Both B and C"
    },
    {
        question: "Which of the following operations is the most expensive in a linked list?",
        option1: "Insertion at the head",
        option2: "Deletion at the tail",
        option3: "Accessing an element at a specific index",
        option4: "Traversal from the head to the tail",
        ans: "Accessing an element at a specific index"
    },
    {
        question: "Which data structure is best for implementing a circular queue?",
        option1: "Array",
        option2: "Linked List",
        option3: "Stack",
        option4: "Graph",
        ans: "Array"
    },
    {
        question: "Which graph traversal algorithm is preferred when searching for the shortest path in an unweighted graph?",
        option1: "Depth-First Search (DFS)",
        option2: "Breadth-First Search (BFS)",
        option3: "Dijkstra’s Algorithm",
        option4: "Prim’s Algorithm",
        ans: "Breadth-First Search (BFS)"
    },
    {
        question: "Which hashing technique helps to resolve collisions?",
        option1: "Chaining",
        option2: "Linear Probing",
        option3: "Quadratic Probing",
        option4: "All of the above",
        ans: "All of the above"
    },
    {
        question: "Which of the following sorting algorithms has the best worst-case time complexity?",
        option1: "Bubble Sort",
        option2: "Merge Sort",
        option3: "QuickSort",
        option4: "Heap Sort",
        ans: "Merge Sort"
    },
    {
        question: "What is the time complexity of heap insertion in a binary heap?",
        option1: "O(1)",
        option2: "O(log n)",
        option3: "O(n)",
        option4: "O(n log n)",
        ans: "O(log n)"
    },
    {
        question: "Which data structure can be used to detect cycles in a directed graph?",
        option1: "Stack",
        option2: "Queue",
        option3: "Disjoint Set (Union-Find)",
        option4: "Binary Search Tree",
        ans: "Disjoint Set (Union-Find)"
    },
    {
        question: "Which of the following traversal algorithms does NOT require recursion or a stack?",
        option1: "Preorder Traversal",
        option2: "Postorder Traversal",
        option3: "Morris Traversal",
        option4: "Level Order Traversal",
        ans: "Morris Traversal"
    },
    {
        question: "Which data structure is best suited for fast dynamic memory allocation and deallocation?",
        option1: "Stack",
        option2: "Heap",
        option3: "Queue",
        option4: "Hash Table",
        ans: "Heap"
    },
    {
        question: "Which of the following is NOT a divide and conquer algorithm?",
        option1: "Merge Sort",
        option2: "QuickSort",
        option3: "Binary Search",
        option4: "Counting Sort",
        ans: "Counting Sort"
    },
    {
        question: "Which tree traversal technique is used in an expression tree for evaluating expressions?",
        option1: "Inorder",
        option2: "Preorder",
        option3: "Postorder",
        option4: "Level Order",
        ans: "Postorder"
    },
    {
        question: "Which of the following algorithms is NOT used for finding the shortest path in a graph?",
        option1: "Bellman-Ford Algorithm",
        option2: "Floyd-Warshall Algorithm",
        option3: "Prim’s Algorithm",
        option4: "Dijkstra’s Algorithm",
        ans: "Prim’s Algorithm"
    },
    {
        question: "Which of the following data structures is best suited for implementing a LRU (Least Recently Used) cache?",
        option1: "Array",
        option2: "Stack",
        option3: "Doubly Linked List + Hash Map",
        option4: "Heap",
        ans: "Doubly Linked List + Hash Map"
    },
    {
        question: "Which of the following is an application of the Disjoint Set data structure?",
        option1: "Graph Traversal",
        option2: "Finding Connected Components",
        option3: "Sorting",
        option4: "Hashing",
        ans: "Finding Connected Components"
    },
    {
        question: "What is the average-case time complexity of searching in an ordered binary search tree?",
        option1: "O(n)",
        option2: "O(log n)",
        option3: "O(n log n)",
        option4: "O(1)",
        ans: "O(log n)"
    },
    {
        question: "Which of the following data structures is used in the implementation of a trie (prefix tree)?",
        option1: "Array",
        option2: "Graph",
        option3: "Linked List",
        option4: "Hash Table",
        ans: "Linked List"
    }
];

export const hardLevel = [
    {
        question: "Which data structure is used in implementing a persistent (immutable) data structure efficiently?",
        option1: "AVL Tree",
        option2: "Red-Black Tree",
        option3: "Trie",
        option4: "Persistent Segment Tree",
        ans: "Persistent Segment Tree"
    },
    {
        question: "Which of the following data structures is best suited for implementing a Least Frequently Used (LFU) cache?",
        option1: "Stack",
        option2: "Queue",
        option3: "Hash Map + Doubly Linked List + Min Heap",
        option4: "Binary Search Tree",
        ans: "Hash Map + Doubly Linked List + Min Heap"
    },
    {
        question: "Which of the following sorting algorithms is not based on comparison?",
        option1: "QuickSort",
        option2: "Merge Sort",
        option3: "Radix Sort",
        option4: "Heap Sort",
        ans: "Radix Sort"
    },
    {
        question: "Which algorithm is used in Tarjan’s Strongly Connected Components (SCC) detection?",
        option1: "Depth-First Search",
        option2: "Breadth-First Search",
        option3: "Dijkstra’s Algorithm",
        option4: "Floyd-Warshall Algorithm",
        ans: "Depth-First Search"
    },
    {
        question: "What is the worst-case time complexity of Splay Tree operations?",
        option1: "O(log n)",
        option2: "O(n)",
        option3: "O(1)",
        option4: "O(n log n)",
        ans: "O(n)"
    },
    {
        question: "Which of the following data structures can be used to implement an O(1) time complexity for insert, delete, and get-random operations?",
        option1: "Linked List",
        option2: "Doubly Linked List",
        option3: "Hash Map + Array",
        option4: "Binary Search Tree",
        ans: "Hash Map + Array"
    },
    {
        question: "Which tree structure is commonly used for implementing databases and file systems?",
        option1: "AVL Tree",
        option2: "Red-Black Tree",
        option3: "B-Tree",
        option4: "Segment Tree",
        ans: "B-Tree"
    },
    {
        question: "Which algorithm is used to detect cycles in an undirected graph in O(n) time?",
        option1: "Depth-First Search (DFS)",
        option2: "Kruskal’s Algorithm",
        option3: "Disjoint Set (Union-Find) with Path Compression",
        option4: "Dijkstra’s Algorithm",
        ans: "Disjoint Set (Union-Find) with Path Compression"
    },
    {
        question: "Which advanced data structure provides logarithmic time complexity for union and find operations?",
        option1: "Binary Search Tree",
        option2: "Segment Tree",
        option3: "Disjoint Set (Union-Find) with Path Compression",
        option4: "Fibonacci Heap",
        ans: "Disjoint Set (Union-Find) with Path Compression"
    },
    {
        question: "What is the time complexity of inserting an element into a Fibonacci Heap?",
        option1: "O(1)",
        option2: "O(log n)",
        option3: "O(n)",
        option4: "O(n log n)",
        ans: "O(1)"
    },
    {
        question: "Which of the following is a self-adjusting binary search tree?",
        option1: "AVL Tree",
        option2: "Red-Black Tree",
        option3: "Splay Tree",
        option4: "Treap",
        ans: "Splay Tree"
    },
    {
        question: "Which data structure can be used to efficiently find the kth smallest element in a stream of numbers?",
        option1: "Binary Search Tree",
        option2: "Heap",
        option3: "Segment Tree",
        option4: "Hash Table",
        ans: "Heap"
    },
    {
        question: "Which graph algorithm is used for solving the 2-SAT problem efficiently?",
        option1: "Dijkstra’s Algorithm",
        option2: "Floyd-Warshall Algorithm",
        option3: "Kosaraju’s Algorithm",
        option4: "Kruskal’s Algorithm",
        ans: "Kosaraju’s Algorithm"
    },
    {
        question: "Which data structure is useful for interval scheduling problems?",
        option1: "Binary Heap",
        option2: "Segment Tree",
        option3: "Trie",
        option4: "Graph",
        ans: "Segment Tree"
    },
    {
        question: "Which of the following operations is the most expensive in a Treap?",
        option1: "Insertion",
        option2: "Search",
        option3: "Merge",
        option4: "Split",
        ans: "Merge"
    },
    {
        question: "Which advanced data structure supports order statistics efficiently?",
        option1: "Treap",
        option2: "AVL Tree",
        option3: "Red-Black Tree",
        option4: "All of the above",
        ans: "All of the above"
    },
    {
        question: "Which algorithm is used for finding articulation points and bridges in a graph?",
        option1: "Prim’s Algorithm",
        option2: "Tarjan’s Algorithm",
        option3: "Kruskal’s Algorithm",
        option4: "Dijkstra’s Algorithm",
        ans: "Tarjan’s Algorithm"
    },
    {
        question: "Which of the following problems can be solved using a Fenwick Tree?",
        option1: "Graph Traversal",
        option2: "Range Sum Queries",
        option3: "Heap Sort",
        option4: "Cycle Detection",
        ans: "Range Sum Queries"
    },
    {
        question: "What is the worst-case time complexity for inserting an element in an AVL tree?",
        option1: "O(1)",
        option2: "O(log n)",
        option3: "O(n)",
        option4: "O(n log n)",
        ans: "O(log n)"
    },
    {
        question: "Which of the following data structures allows O(1) insertion and deletion from both ends?",
        option1: "Queue",
        option2: "Deque",
        option3: "Stack",
        option4: "Binary Search Tree",
        ans: "Deque"
    },
    {
        question: "Which data structure is used for implementing Prim’s Algorithm efficiently?",
        option1: "Queue",
        option2: "Stack",
        option3: "Binary Heap",
        option4: "Trie",
        ans: "Binary Heap"
    },
    {
        question: "Which data structure is used to efficiently perform range updates and point queries?",
        option1: "Segment Tree",
        option2: "Trie",
        option3: "Graph",
        option4: "Heap",
        ans: "Segment Tree"
    },
    {
        question: "Which of the following is NOT an application of a priority queue?",
        option1: "Dijkstra’s Algorithm",
        option2: "A* Algorithm",
        option3: "Job Scheduling",
        option4: "Graph Traversal",
        ans: "Graph Traversal"
    },
    {
        question: "Which data structure is most efficient for dynamic median-finding?",
        option1: "Red-Black Tree",
        option2: "Segment Tree",
        option3: "Heap (Min and Max)",
        option4: "Hash Table",
        ans: "Heap (Min and Max)"
    },
    {
        question: "Which of the following algorithms is best for solving the longest increasing subsequence problem in O(n log n) time?",
        option1: "Dynamic Programming",
        option2: "Binary Search + DP",
        option3: "Segment Tree",
        option4: "Floyd-Warshall",
        ans: "Binary Search + DP"
    },
    {
        question: "Which of the following is a self-balancing binary search tree that stores a priority value at each node?",
        option1: "AVL Tree",
        option2: "Red-Black Tree",
        option3: "Treap",
        option4: "B-Tree",
        ans: "Treap"
    }
];

export const ds = [easyLevel, mediumLevel, hardLevel];
